function [V_new, policy_K_matrix] = bellman_1(...
    k_grid, z_grid, V_next, prob_z_transition, ...
    params, cost_type)
% BELLMAN_1 Computes the updated value function and capital policy matrix
% for a dynamic investment problem with discrete capital and productivity grids.
%
% This function solves the Bellman equation for a firm choosing whether
% to adjust its capital stock, facing either fixed or proportional adjustment costs.
% The model includes technology shocks and capital depreciation.
%
% PARAMETERS:
%   k_grid              - (Nk x 1) Vector of discrete capital levels.
%   z_grid              - (Nz x 1) Vector of productivity levels in levels (not log).
%   V_next              - (Nk x Nz) Value function at the next iteration.
%   prob_z_transition   - (Nz x Nz) Markov transition matrix for productivity z.
%   params              - Struct with model parameters:
%       .theta   - Capital share in production function.
%       .R       - Cost of capital.
%       .delta   - Depreciation rate.
%       .beta    - Discount factor.
%       .F       - Fixed adjustment cost (used if cost_type == 'fixed').
%       .P       - Proportional adjustment cost (used if cost_type == 'proportional').
%       .k_points, .logz_points - Number of grid points in k and z respectively.
%   cost_type           - String, either 'fixed' or 'proportional', indicating the type
%                         of adjustment cost applied when changing capital.
%
% RETURNS:
%   V_new               - (Nk x Nz) Updated value function matrix.
%   policy_K_matrix     - (Nk x Nz) Matrix with the optimal capital choice for each (k,z).
%
% DESCRIPTION:
% For each current state (k, z), the function evaluates two options:
%   - No adjustment: The firm keeps capital constant (only subject to depreciation).
%   - Adjustment: The firm can choose a new capital level from the grid, incurring
%                 either a fixed or proportional adjustment cost.
%
% For both cases, it computes:
%   - Current profits: z * k^theta - R * k
%   - Continuation value: interpolated V_next at (1 - delta) * k'
%   - Total value: profit + discounted expected value (using prob_z_transition)
%
% The function compares both options and chooses the one with the highest value.
% It returns the new value function and the corresponding capital policy.
%
% NOTE:
%   - Linear interpolation is used to evaluate the continuation value when
%     the post-depreciation capital (1 - delta) * k is not exactly on the grid.
%   - The capital choice policy is conditional on the decision to adjust or not.
%
% AUTHOR: [Your Name or Institution]
% DATE: [Optional: Date or Version]

    % =====================================================================
    % NOT ADJUST ==========================================================
    % =====================================================================
    profit_if_not_adjust_mat = z_grid' .* (k_grid.^params.theta) - params.R .* k_grid; 
    K_next_if_not_adjust_vec = (1 - params.delta) * k_grid; % (Nk x 1)

    V_interp_for_no_adjust = zeros(params.k_points, params.logz_points); % (Nk x Nz_next)
    for i_z_next = 1:params.logz_points
        V_interp_for_no_adjust(:, i_z_next) = interp1(k_grid, V_next(:, i_z_next), K_next_if_not_adjust_vec, 'linear', 'extrap');
    end
    E_V_no_adjust = V_interp_for_no_adjust * prob_z_transition'; % (Nk x Nz)
    V_no_adjust = profit_if_not_adjust_mat + params.beta * E_V_no_adjust; % (Nk x Nz)

    % =====================================================================
    % ADJUST ==============================================================
    % =====================================================================    
    K_prime_candidates = k_grid; % (Nk x 1)
    Profit_at_k_prime_z = z_grid' .* (K_prime_candidates.^params.theta) - params.R .* K_prime_candidates; 

    Adjustment_cost_at_k_prime_z = zeros(params.k_points, params.logz_points); % (Nk_prime x Nz)
    if strcmpi(cost_type, 'fixed') % Asumiendo que tienes params.cost_type
        Adjustment_cost_at_k_prime_z = params.F; % Scalar, se expandirÃ¡
    elseif strcmpi(cost_type, 'proportional')
        Adjustment_cost_at_k_prime_z = params.P * max(0, Profit_at_k_prime_z);
    end
    K_prime_next_if_adjust_vec = (1 - params.delta) * K_prime_candidates; % (Nk x 1)
    
    V_interp_for_adjust = zeros(params.k_points, params.logz_points); % (Nk_prime x Nz_next)
    for i_z_next = 1:params.logz_points
        V_interp_for_adjust(:, i_z_next) = interp1(k_grid, V_next(:, i_z_next), K_prime_next_if_adjust_vec, 'linear', 'extrap');
    end
    E_V_adjust_k_prime_z = V_interp_for_adjust * prob_z_transition'; % (Nk_prime x Nz)
    
    % (Nk_prime x Nz)
    Value_candidate_if_adjust = Profit_at_k_prime_z - Adjustment_cost_at_k_prime_z + params.beta * E_V_adjust_k_prime_z; 
    
    [V_adjust_for_z_row, Idx_optimal_K_prime_for_z_row] = max(Value_candidate_if_adjust, [], 1);

    Policy_K_prime_if_adjust_for_z_col = k_grid(Idx_optimal_K_prime_for_z_row'); % (Nz x 1)
    V_adjust = repmat(V_adjust_for_z_row, params.k_points, 1); % (Nk x Nz)
    
    V_new = max(V_no_adjust, V_adjust); % (Nk x Nz)
    Adjust_decision_mat = (V_adjust > V_no_adjust); % (Nk x Nz)

    Policy_K_chosen_if_adjust_mat = repmat(Policy_K_prime_if_adjust_for_z_col', params.k_points, 1); % (Nk x Nz)
    Current_K_mat = repmat(k_grid, 1, params.logz_points); % (Nk x Nz)
    
    policy_K_matrix = Adjust_decision_mat .* Policy_K_chosen_if_adjust_mat + (~Adjust_decision_mat) .* Current_K_mat;
    % (Nk x Nz)

end

